#!/usr/bin/env python3
#
# ==============
# NEVER FINISHED THIS
# ==============
#
# syncs credential/secret dotfiles across my computers using syncthing
# setting up individual syncthing directives
# for each of these is annoying, so this just
# sets up those hardlinks for me into the shared ~/Sync/syncdots folder
#
# If a file exists in that folder but the corresponding file doesn't exist
# on my computer, this hardlinks the file from syncthing to here
#
# If any file doesn't exist in the syncthing (~/Sync/syncdots) folder which exists
# here, hardlink it from the location into the syncdots folder
#
# If the file is already synced to my dotfiles (using yadm; checked using yadm ls-files)
# don't sync it here as well
#
# An example:
#
# Line in ~/.config/syncdots.conf:
# ~/.config/my/my/config/
# Hardlinks ~/.config/my/my/config to ~/Repos/syncdots/.config/my/my/config

import sys
import os
import shlex
import subprocess
import functools
import itertools

from typing import Iterator, List, Union, Set, Optional
from pathlib import Path

subprocess_piped = functools.partial(
    subprocess.run,
    encoding="utf-8",
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE,
)

# make sure we're working relative to the home directory
os.chdir(os.environ["HOME"])

home = os.environ["HOME"]
sync_target: Path = Path(home) / "Sync" / "syncdots"

if not sync_target.exists():
    sync_target.mkdir(parents=True)

# configuration
syncdots_conf: Path = (
    Path(os.environ.get("XDG_CONFIG_HOME", os.path.join(os.environ["HOME"], ".config")))
    / "syncdots.conf"
)
assert syncdots_conf.exists(), "Syncdots config file doesn't exist"


def subprocess_absolute_filepaths(cmd: str, warn: bool = False) -> Iterator[str]:
    """
    Execute a command
    Make sure it didn't fail
    return lines from STDOUT that exist
    """
    proc: subprocess.CompletedProcess = subprocess_piped(shlex.split(cmd))
    proc.check_returncode()
    for path in proc.stdout.splitlines():
        rpath: str = os.path.abspath(os.path.expanduser(path))
        exists = os.path.exists(rpath)
        if warn and not exists:
            print("Warning: {} does not exist".format(rpath), file=sys.stderr)
        if exists:
            yield rpath


def collect_files(files: Union[str, List[str]]) -> List[str]:
    if isinstance(files, list):
        return list(itertools.chain(*map(collect_files, files)))
    else:
        # this is a path or a directory
        assert isinstance(files, str)
        if os.path.isdir(files):
            fnames = []
            for dirpath, _, filenames in os.walk(files, followlinks=False):
                fnames.extend([os.path.join(dirpath, f) for f in filenames])
            return fnames
        else:
            return [files]


# same as above but unique
def ucollect_files(files: Union[str, List[str]]) -> Set[str]:
    return set(collect_files(files))


# collect all files which should be synced from my local computer
def collect_syncdots_files() -> List[str]:
    # https://github.com/seanbreckenridge/spkglist
    syncdots_lines: List[str] = list(
        subprocess_absolute_filepaths(f'spkglist "{str(syncdots_conf)}"', warn=True)
    )
    yadm_lines: List[str] = list(subprocess_absolute_filepaths("yadm ls-files"))

    # files in ~/.config/syncdots.conf but not returned by yadm ls-files
    sync_paths: Set[str] = ucollect_files(syncdots_lines).difference(
        ucollect_files(yadm_lines)
    )
    return list(sync_paths)


# removes $HOME from the front of a string
def remove_prefix_home(path: str) -> Optional[str]:
    if path.startswith(home):
        return path.lstrip(home)
    else:
        print("Warning: {} doesn't start with $HOME")
        return None


def main() -> None:
    syncdots_files = [f for f in map(remove_prefix_home, collect_syncdots_files()) if f is not None]
    for f in syncdots_files:
        local_file: Path = Path(os.path.join(home, f))
        synced_file: Path = sync_target / f

        if local_file.exists() and not synced_file.exists():
            # if exists here but not there
            pass
        elif synced_file.exists() and not local_file.exists():
            # if exists there but not here
            pass



if __name__ == "__main__":
    main()
