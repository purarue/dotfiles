#!/usr/bin/env python3

"""
https://github.com/seanbreckenridge/plaintext-playlist

A script which hardlinks all current files in my playlists to a separate
folder structure, so that folder can be synced across my devices

This allows me to sync songs I like (i.e. ones in playlist) across
all my devices without using a ton of space

This works sort of like rsync --delete-after

The TARGET directory is provided as the first argument to this script

\b
- Creates an index of items in the TARGET directory
- Hardlink any files from my PLAINTEXT_PLAYLIST_MUSIC_DIR into the TARGET directory
- If there were any files in the index of the files in the TARGET directory that weren't
  copied, remove those from TARGET; those are items I deleted from playlists/renamed
- Remove any empty directories in the TARGET directory

I sync this across my computers/phone by using syncthing
"""

import sys
import os
from pathlib import Path
from typing import Iterator

import click
from logzero import logger  # type: ignore[import]

from seanb.playlists import PlaylistPath, iterate_playlists, playlistdir


def _check_os() -> None:
    ON_OS = os.environ.get("ON_OS")
    if ON_OS is None:
        raise ValueError(
            "$ON_OS environment variable is none. Set to 'linux' to let this run"
        )
    else:
        if ON_OS == "linux":
            return
        raise ValueError(
            "$ON_OS environment variable is not linux. This should only run on my linux machine"
        )


def iter_files(in_dir: Path) -> Iterator[str]:
    """Recursively List files in a directory"""
    yield from map(
        lambda f: str(f.absolute()), filter(lambda f: f.is_file(), in_dir.rglob("*"))
    )


def remove_empty_dir(path: str) -> None:
    try:
        os.rmdir(path)
    except OSError:
        pass
    else:
        logger.debug(f"Removed empty directory {path}")


def remove_empty_dirs(path: str) -> None:
    # remove empty directories
    for root, dirnames, filenames in os.walk(path, topdown=False):
        for dirname in dirnames:
            if dirname.startswith("."):
                continue
            remove_empty_dir(os.path.realpath(os.path.join(root, dirname)))


def hardlink_sync_dirs(files: list[PlaylistPath], to_dir: Path, delete: bool) -> None:
    """
    Essentially a manual rsync --delete-after with hardlinks
    Copies all items from files into to_dir, deletes and items
    that weren't mentioned
    """
    to_dir.mkdir(parents=True, exist_ok=True)
    already_in_set: set[str] = set()
    # recursively iterate through files already in to_dir
    # get relative paths to taret directory so we can compare
    for absf in iter_files(to_dir):
        already_in_set.add(absf[len(str(to_dir)) + 1 :])

    # copy link if it doesnt already exist on target
    for p in files:
        target = p.in_dir(to_dir)
        if not target.exists():
            target.parent.mkdir(parents=True, exist_ok=True)
            source = p.in_musicdir()
            logger.info(f"Linking from '{source}' to '{target}'")
            target.hardlink_to(source)
        # remove from set, so at the end we can check
        # the set. If theres anything left in it,
        # that wasn't included in the 'files' list,
        # i.e. its been deleted from a playlist
        ps = p.path.strip(os.linesep)
        if ps in already_in_set:
            already_in_set.remove(ps)

    if delete:
        for removed in already_in_set:
            to_remove: Path = PlaylistPath(removed).in_dir(to_dir)
            # dont remove hidden files
            if to_remove.stem.startswith("."):
                continue
            logger.info(f"Removing '{to_remove}'...")
            to_remove.unlink()

        remove_empty_dirs(str(to_dir))


@click.command(help=__doc__)
@click.option(
    "--bypass",
    default=False,
    is_flag=True,
    help="Dont check the $ON_OS environment variable to make this is running on my linux machine",
)
@click.option(
    "--delete",
    "delete",
    default=False,
    is_flag=True,
    help="Delete files that I've removed from my playlists",
)
@click.argument("SYNC_TO", type=click.Path())
def main(bypass: bool, sync_to, delete: bool):
    if not bypass:
        try:
            _check_os()
        except ValueError as e:
            click.echo(str(e), err=True)
            click.echo("To ignore this, pass --bypass")
            sys.exit(1)
    playlistlines = list(iterate_playlists(playlistdir()))
    logger.info(f"Syncing {len(playlistlines)} files...")
    assert len(playlistlines) > 0
    hardlink_sync_dirs(playlistlines, Path(sync_to), delete=delete)
    logger.info("Done!")


if __name__ == "__main__":
    main(prog_name="linkmusic")
