#!/usr/bin/env python3
import sys
import os
import time
import subprocess
import logging
from typing import TextIO, Iterable
from concurrent.futures import ThreadPoolExecutor, Future, as_completed

import click

USAGE = """\
Instead of reminding me every 'n' duration to do something, this uses local
data to check if I've done it within that duration

e.g., whenever I have my vitamins, I log that with
https://github.com/seanbreckenridge/ttally, and this script checks if I've
taken them within the last 24 hours

This works by calling other bash scripts which return a zero exit
code if I've done the thing recently, else exits with an exit
code 2 or 3 (2 meaning print the name of the script, 3 meaning print the output
of the script)

Number of scripts which have expired gets displayed in my menu bar, and if
I click it it sends a notification with the script name, which lets me know
what I have left to do

This makes these reminders less obtrusive since I don't have to feel like
I have to do it when some notify-send is sent, but it still reminds me to do
things since the number sits there while I haven't

This runs all scripts as bash, though you could wrap another language in a bash
script if you wanted to use something else

To disable a script, make it non executable, or add a .disabled to the end of
the filename. To enable it, make it executable or add a .enabled to the end of
the filename

\b For examples of the scripts, you can see mine here:
https://github.com/seanbreckenridge/dotfiles/tree/master/.local/scripts/sreminders
"""


def executable(path: str) -> bool:
    return os.access(path, os.X_OK)


def find_execs() -> Iterable[str]:
    dirs = os.environ.get("SREMINDERS_PATH")
    if not dirs:
        click.echo(
            "The SREMINDERS_PATH environment variable is not set. "
            "It should contain a colon-delimited list of directories "
            "that contain sreminder jobs. "
            "For example, in your shell profile, set:\n"
            'export SREMINDERS_PATH="${HOME}/.local/sreminders:${HOME}/data/sreminders"'
        )
        return
    for d in dirs.rstrip(":").split(":"):
        logging.debug(f"Searching {d}")
        if not os.path.isdir(d):
            click.echo(f"Error: {d} is not a directory", err=True)
            continue
        for root, _, files in os.walk(d, followlinks=True):
            for file in files:
                abspath = os.path.join(root, file)
                if file.endswith(".disabled"):
                    continue
                if executable(abspath) or file.endswith(".enabled"):
                    yield abspath

        logging.debug(f"Finished searching {d}")


INTERPRETER = os.environ.get("SREMINDERS_INTERPRETER", "bash")


def script_name(script: str) -> str:
    path = os.path.basename(script)
    return os.path.splitext(path)[0]


Result = tuple[str, int, str]


def run_script(script: str) -> Result:
    name = script_name(script)
    logging.debug(f"{name}: Starting {repr(script)}")
    start = time.perf_counter()
    proc = subprocess.Popen(
        [INTERPRETER, script],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        universal_newlines=True,
    )
    exitcode = proc.wait()

    output = proc.stdout.read() if proc.stdout else ""

    assert proc.stderr is not None, "stderr should be a pipe"
    for line in proc.stderr:
        logging.warning(f"{name}: {line.rstrip()}")

    logging.debug(
        f"Finished: {name} (took {time.perf_counter() - start}) with exit code {exitcode} and output {repr(output.strip())}"
    )
    return name, exitcode, output


def run_parallel_scripts(
    executables: Iterable[str],
) -> Iterable[Future[Result]]:
    cpu_count = os.cpu_count()
    logging.debug(f"Running scripts with {cpu_count} threads")
    with ThreadPoolExecutor(max_workers=cpu_count) as executor:
        for script in executables:
            yield executor.submit(run_script, script)


def print_result(res: Result, out: TextIO) -> None:
    name, exitcode, output = res
    match exitcode:
        case 0:
            pass
        case 1:
            logging.error(f"{name}: failed. Pass -d for more information")
        case 2:
            out.write(name + "\n")
        case 3:
            out.write(output.rstrip("\n") + "\n")


def write_results(futures: Iterable[Future[Result]], out: TextIO) -> None:
    for future in as_completed(futures):
        print_result(future.result(), out)


FORMAT = "%(asctime)s %(levelname)s - %(message)s"


@click.command(help=USAGE, context_settings={"help_option_names": ["-h", "--help"]})
@click.option("-d", "--debug", is_flag=True, help="print debug information")
@click.option(
    "-l", "--list", "list_scripts", is_flag=True, help="list scripts which would be run"
)
def main(list_scripts: bool, debug: bool) -> None:
    if debug:
        logging.basicConfig(level=logging.DEBUG, format=FORMAT)
    else:
        logging.basicConfig(level=logging.INFO, format=FORMAT)

    executables = find_execs()

    if list_scripts:
        click.echo("\n".join(list(executables)))
    else:
        write_results(run_parallel_scripts(executables), sys.stdout)
        sys.stdout.flush()


if __name__ == "__main__":
    main()
