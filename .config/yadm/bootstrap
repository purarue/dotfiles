#!/usr/bin/env bash
# yadm bootstrap script
# Installs all my packages/sets up my environment.
#
# Checks for the presence of the $ONLINUX variable,
# which is set in ~/.profile by checking `uname`
# on linux. Since the ~/.profile is sourced at the
# beginning of the Xsession and not when opening
# a shell, it can be assumed that its always set
# once `yadm clone` has been run and the computer
# has been restarted.

print_error() {
	notify -u critical "bootstrap error" "$1"
	printf '%s%s%s\n' "$(tput setaf 1)" "${1}" "$(tput sgr0)" 1>&2
} && export -f print_error

abort() {
	print_error "${1}"
	exit 1
} && export -f abort

# install my package list parser
install_spkglist() {
	havecmd go || return $?
	if ! havecmd spkglist; then
		go get -u -v 'github.com/seanbreckenridge/spkglist/cmd/spkglist' || return $?
	fi
} && export -f install_spkglist

declare -rx YADM_DIR="${HOME}/.config/yadm"
declare -rx PACKAGE_DIR="${YADM_DIR}/package_lists"

# report errors if user doesn't have a command
export HAVECMD_REPORT=1

# make sure $PATH is set up properly, havecmd (to check for commands on the my $PATH) exists
set -e
havecmd havecmd
set +e

# dispatch on os type
if [[ -z "${ONLINUX}" ]]; then
	bash "${YADM_DIR}/mac_bootstrap" || exit $?
else
	bash "${YADM_DIR}/linux_bootstrap" || exit $?
fi

declare -rx PYTHON_PACKAGE_LIST="${PACKAGE_DIR}/python3_packages.txt"
declare -rx GLOBAL_GEM_LIST="${PACKAGE_DIR}/ruby_packages.txt"
declare -rx NODE_PACKAGE_LIST="${PACKAGE_DIR}/node_packages.txt"
declare -rx DART_PACKAGE_LIST="${PACKAGE_DIR}/dart_packages.txt"
declare -rx CARGO_PACKAGE_LIST="${PACKAGE_DIR}/cargo_packages.txt"
declare -rx GO_PACKAGE_LIST="${PACKAGE_DIR}/go_packages.txt"
declare -rx HASKELL_PACKAGE_LIST="${PACKAGE_DIR}/haskell_packages.txt"
declare -rx MIX_PACKAGE_LIST="${PACKAGE_DIR}/mix_archive_packages.txt"

declare SCRIPT_TARGET_DIR="${HOME}/.local/bin" # should be created by stack/python

# make sure personal aliases file exists so that zshrc souces fine
[[ ! -f "${ZDOTDIR}/aliases/personal_aliases" ]] && touch "${ZDOTDIR}/aliases/personal_aliases"

# create default user directories
default_user_dirs=("Repos" "Documents" "Documents/Notes" "Documents/wallpapers" "GoogleDrive" "Downloads" "Pictures/Screenshots" "Pictures" ".local" ".cache" ".credentials" "data" "Sync")
for d_name in "${default_user_dirs[@]}"; do
	if [[ ! -d "${HOME}/${d_name}" ]]; then
		mkdir -p "${HOME}/${d_name}"
	fi
done

havecmd git || exit $?
echo 'Checking git config...'
# check for global name config
if [[ -z $(git config --global user.name) ]]; then
	printf "No global name set. Enter full name: "
	read -r githubusername
	git config --global user.name "${githubusername}"
fi
# check for global email config
if [[ -z $(git config --global user.email) ]]; then
	printf "No global email set. Enter email connected to your GitHub account: "
	read -r githubemail
	git config --global user.email "${githubemail}"
fi
# set editor to use as nvim
git config --global core.editor nvim
# specify how to handle divergent branches
git config --global pull.rebase false
# set default branch to silence warning message
git config --global init.defaultBranch 'master'
# set similar configuration for yadm itself
yadm gitconfig core.editor nvim
yadm gitconfig pull.rebase false

# set the hooks directory
yadm gitconfig core.hooksPath ~/.config/yadm/hooks

havecmd python3 || exit $?
# Install python packages
echo "Installing global python site-packages..."
python3 -m pip list --format=freeze | cut -d "=" -f1 | grep -q "^wheel$" || python3 -m pip install --user wheel
python3 -m pip install -q --user -r "${PYTHON_PACKAGE_LIST}"

# Install personal python packages
# If command "$1" doesn't exist, install from $2
function install_python_personal() {
	havecmd "${1}" || python3 -m pip install --user "git+${2}"
}
install_python_personal "plus1" "https://github.com/seanbreckenridge/plus1"
install_python_personal "pythonanywhere_3_months" "https://github.com/seanbreckenridge/pythonanywhere-3-months"
install_python_personal "rotten" "https://github.com/seanbreckenridge/rotten_tomatoes_cli"
install_python_personal "mystars" "https://github.com/seanbreckenridge/oh-my-stars"
install_python_personal "calcurse_load" "https://github.com/seanbreckenridge/calcurse-load"

# speedtest installs 2 executable scripts
# speedtest and speedtest-cli, which both have the same
# functionatly. This removes speedtest-cli to make
# tab completion nicer
HAVECMD_REPORT='' havecmd speedtest-cli && rm "$(command -v speedtest-cli)"

havecmd npm || exit $?
# install npm packages
export NPM_CONFIG_PREFIX="${XDG_DATA_HOME}/npm-packages"
echo "Installing global npm packages..."
NPM_LOC="$(command -v npm)"
if grep -q 'npm-packages' <<<"$NPM_LOC"; then
	# create the npm directory and make sure we own the directory to fix permission issues
	[[ ! -d "${NPM_CONFIG_PREFIX}" ]] && mkdir -p "${NPM_CONFIG_PREFIX}" && sudo chown -R "$(whoami)" "${NPM_CONFIG_PREFIX}"
	# get a list of installed packages
	NPM_PACKAGE_LIST="$(npm ls -g --json | jq '.dependencies | keys[]' -r)"
	while read -r npkg; do
		if ! grep -q "^${npkg}$" <<<"${NPM_PACKAGE_LIST}"; then
			printf "Installing %s\n" "$npkg"
			npm install --global "${npkg}"
		fi
	done < <(spkglist "${NODE_PACKAGE_LIST}")
else
	printf "NPM path not where expected (%s), skipping package install...\n" "$NPM_LOC"
	# incase this is the first time this has happened, update npm globally so it gets put into "$NPM_CONFIG_PREFIX"
	npm install --global npm
fi

echo 'Installing coc extensions...'
COC_NPM_DIR="${HOME}/.config/coc/extensions/"
havecmd npm && [[ -e "${COC_NPM_DIR}" ]] && {
	(cd "${COC_NPM_DIR}" && npm install)
}

havecmd gem || exit $?
echo "Installing global ruby packages..."
RUBY_GEMS_LIST="$(gem list | cut -d' ' -f1)"
while read -r rgem; do
	if ! grep -q "^${rgem}$" <<<"${RUBY_GEMS_LIST}"; then
		printf "Installing %s\n" "${rgem}"
		gem install "${rgem}"
	fi
done < <(spkglist "${GLOBAL_GEM_LIST}")

havecmd pub || exit $?
echo "Installing global dart packages..."
DART_INSTALLED_PACKAGES="$(pub global list | cut -d" " -f1)"
while read -r dartpkg; do
	if ! grep -q "^${dartpkg}$" <<<"${DART_INSTALLED_PACKAGES}"; then
		printf "Installing %s\n" "${dartpkg}"
		pub global activate "${dartpkg}"
	fi
done < <(spkglist "${DART_PACKAGE_LIST}")

havecmd cargo || exit $?
echo "Installing global cargo packages..."
CARGO_INSTALLED_PACKAGES="$(cargo install --list | sed -E -e '/^\s+/d; s|\s.*||')"
while read -r cargopkg; do
	if ! grep -q "^${cargopkg}$" <<<"${CARGO_INSTALLED_PACKAGES}"; then
		printf "Installing %s\n" "${cargopkg}"
		cargo install "${cargopkg}"
	fi
done < <(spkglist "${CARGO_PACKAGE_LIST}")

havecmd go || exit $?
# takes a line from "$GO_PACKAGE_LIST"
# binary -> package source
# and installs it if the binary isn't already on your path
function install_go_package() {
	local -a packageinfo
	read -ra packageinfo <<<"${1}"
	havecmd "${packageinfo[0]}" || go get -u -v "${packageinfo[1]}"
}
# install pistol manually
havecmd pistol || env GO111MODULE=on go get -v -u github.com/doronbehar/pistol/cmd/pistol

echo "Installing global go packages..."
while IFS= read -r go_line; do
	install_go_package "${go_line}"
done < <(spkglist "${GO_PACKAGE_LIST}")

havecmd stack || exit $?
echo "Installing global haskell packages..."
while read -r haskell_pkg; do
	havecmd "${haskell_pkg}" || stack install "${haskell_pkg}"
done < <(spkglist "${HASKELL_PACKAGE_LIST}")

havecmd emacs || exit $?
# Install doom emacs
if [[ ! -d "${HOME}/.emacs.d/" ]]; then
	git clone https://github.com/hlissner/doom-emacs "${HOME}/.emacs.d"
	"${HOME}/.emacs.d/bin/doom" install
	"${HOME}/.emacs.d/bin/doom" sync
fi

havecmd mix || exit $?
echo "Installing global pheonix mix archives..."
MIX_ARCHIVE_LIST="$(mix archive | tac | sed -e '1d; s/^* //; s/-.*//')"
while read -r mix_pkg; do
	if ! grep -q "^${mix_pkg}$" <<<"${MIX_ARCHIVE_LIST}"; then
		mix archive.install hex "${mix_pkg}"
	fi
done < <(spkglist "${MIX_PACKAGE_LIST}")

echo "Installing personal tools/scripts..."

# install git-only cargo repos
havecmd "wait-for-internet" || cargo install --git "https://github.com/seanbreckenridge/wait-for-internet"

# build individual applications
# clone from second argument (git), cd and run 'make' to install something
# third argument is passed to make if provided
make_compatible_build() {
	local TEMP_INSTALL_DIR
	havecmd "${1}" || {
		printf "Installing %s from %s\n" "${1}" "${2}"
		BUILD_DIR="$(mktemp -p /tmp -d XXXXXXXXXX)"
		cd "${BUILD_DIR}" || return $?
		git clone "${2}" || return $?
		CLONED="$(command ls -1)" || return $?
		cd "${CLONED}" || return $?
		if [[ -n "${3}" ]]; then
			make "${3}" || return $?
		else
			make || return $?
		fi
	}
}

set -e
make_compatible_build tttlog 'https://github.com/seanbreckenridge/ttt'
make_compatible_build exists 'https://github.com/seanbreckenridge/exists' install
make_compatible_build genpasswd 'https://github.com/seanbreckenridge/genpasswd' install
make_compatible_build mpv-currently-playing 'https://github.com/seanbreckenridge/mpv-sockets' all
set +e

# install largechar
if ! havecmd largechar; then
	LARGECHAR_LOCATION="${REPOS:-${HOME}/Repos}/largechar"
	[[ ! -e "$LARGECHAR_LOCATION" ]] && git clone 'https://github.com/seanbreckenridge/largechar' "$LARGECHAR_LOCATION"
	set -e
	cd "$LARGECHAR_LOCATION"
	make
	set +e
fi

install_shell_script() {
	local TEMP_INSTALL_DIR
	havecmd "$1" || {
		printf "Installing %s from %s\n" "$1" "$2"
		TEMP_INSTALL_DIR="$(mktemp -p /tmp -d XXXXXXXXXX)" # create temporary directory
		cd "${TEMP_INSTALL_DIR}" || return $?              # switch to directory
		wget "${2}" -O "./${1}" || return $?               # download to script name
		chmod +x "./${1}" || return $?                     # make executable
		mv "./${1}" "${SCRIPT_TARGET_DIR}"                 # move to bin directory (~/.local/bin)
	}
}

# install some of my individual shell scripts
set -e
ls "${SCRIPT_TARGET_DIR}" >/dev/null # make sure target directory exists
install_shell_script calfzf 'https://raw.githubusercontent.com/seanbreckenridge/calories-fzf/master/calfzf'
install_shell_script mpvf 'https://raw.githubusercontent.com/seanbreckenridge/mpvf/master/mpvf'
install_shell_script bgproc 'https://raw.githubusercontent.com/seanbreckenridge/bgproc/master/bgproc'
install_shell_script tts 'https://raw.githubusercontent.com/seanbreckenridge/tts/master/tts'
install_shell_script plainplay 'https://raw.githubusercontent.com/seanbreckenridge/plaintext-playlist/master/plainplay'
install_shell_script resolve_cmd_plainplay 'https://raw.githubusercontent.com/seanbreckenridge/plaintext-playlist/master/resolve_cmd_plainplay'
install_shell_script shortcuts 'https://raw.githubusercontent.com/seanbreckenridge/shortcuts/master/shortcuts'
install_shell_script pmark 'https://raw.githubusercontent.com/seanbreckenridge/pmark/master/pmark'
install_shell_script bookmark 'https://raw.githubusercontent.com/seanbreckenridge/bookmark.txt/master/bookmark'
set +e

havecmd shortcuts && printf "Created %d shortcuts\n" "$(shortcuts create | wc -l)"

# link tmux configuration
[[ ! -e "${HOME}/.tmux.conf" ]] && ln "${HOME}/.config/tmux.conf" "${HOME}/.tmux.conf"

# setup directory for ranger
dir-aliases-ranger

# setup nvim packages
havecmd nvim || exit $?
echo "Installing nvim packages..."
nvim +PlugInstall +qall

# setup calories (https://github.com/zupzup/calories) config file
if [[ -n "${GOBIN}" ]]; then
	# is just a file with a single line, which points to the calories database
	CALORIES_CONF_FILE="${GOBIN}/.caloriesconf"
	[[ -e "${GOBIN}" ]] || mkdir -vp "${GOBIN}"
	CALORIES_DB="${HOME}/data/calories.db"
	[[ -e "${CALORIES_DB}" ]] || echo "Couldn't setup calories, database file doesn't exist"
	printf '%s' "${CALORIES_DB}" > "${CALORIES_CONF_FILE}"
	chmod +x "${CALORIES_CONF_FILE}"
fi

echo "Finished bootstrapping!" | boxes -d shell -p t1l2b1r2
