local M = {}

-- parse the codespell diagnostics generated by nvim-lint,
-- let me select one of the suggested codespell fixes interactively
-- using vim.ui.select, and replace that word in the file
---@return nil
function M.codespell_fix()
    --- codespell diagnostics
    ---@type vim.Diagnostic[]
    local misspellings = vim.iter(vim.diagnostic.get(0))
        :filter(function(d)
            return d.source == "codespell"
        end)
        :totable()

    table.sort(misspellings, function(a, b)
        return a.lnum < b.lnum
    end)

    -- helper function for easier to read control flow
    --
    -- if there's one on the current line, use that, otherwise
    -- pick the next item, otherwise use the first
    ---@return vim.Diagnostic|nil
    local function pick()
        local curline = vim.fn.line(".") - 1
        for _, d in ipairs(misspellings) do
            if d.lnum >= curline then
                return d
            end
        end

        return misspellings[1]
    end

    local chosen = pick()
    if chosen == nil then
        return vim.notify("No misspelled words")
    end

    -- jump to that location
    vim.fn.cursor(chosen.lnum + 1, chosen.col + 1)
    -- parse possible corrections from the message
    local parts = vim.split(chosen.message, " ==> ")
    if #parts ~= 2 then
        return vim.notify("Could not split " .. chosen.message .. " into parts")
    end
    -- even if there's one option, I should confirm so it doesn't replace something
    -- I was not expecting
    vim.ui.select(vim.split(parts[2], ", "), { prompt = "Replace '" .. parts[1] .. "' with" }, function(choice)
        if choice == nil then
            return
        end
        -- replace that word in the file
        local old = vim.fn.getline(chosen.lnum + 1)
        -- if its no longer there, skip it (%f[%a] is a frontier pattern to match word boundaries)
        if not old:match("%f[%a]" .. parts[1] .. "%f[%A]") then
            vim.notify("Could not find '" .. parts[1] .. "' in line, skipping")
            return
        end
        vim.fn.setline(chosen.lnum + 1, old:sub(1, chosen.col) .. choice .. old:sub(chosen.end_col + 1))
    end)
end

return M
